# 空域滤波

[TOC]

## 1. 基本原理

空域滤波是在图像空间通过邻域操作完成的，邻域操作通常借助模板来实现。通过模板对于邻域的像素值进行线性、非线性变换。进行卷积操作。**将每一个像素值置为其邻域像素值的线性和**。

## 2. 基本分类

### 2.1 线性滤波器

+ 低通滤波器

  衰减或者消除频域中的高频分量，达到图像模糊（平滑）的效果。

+ 高通滤波器

  衰减或者消除低频分量，达到锐化的效果（边缘锐化或者细节锐化）。

+ 带通滤波器

  删除图像高频以及低频之间的指定的频域，用于图像修复，不用于增强。

### 2.2 非线性滤波器

分线性滤波器也使用图像的邻域，但是不给定系数，例如中值滤波、最大值、最小值滤波

### 2.3 平滑滤波

用于减弱或者消除图像中的高频分量，但是不影响低频分量。**高频分量对应图像的区域边缘等灰度值较大、变化较快的部分，所以使用平滑滤波可以减少局部灰度的起伏，用于模糊以及去噪。** 所有的滤波模板都需要进行归一化处理。

+ 低通滤波，最简单的滤波模板使用邻域均值（均值滤波），以及高斯滤波器。

  ![gauss](http://media.innohub.top/190519-gauss.png)

  

  高斯平均是一种加权平均，其模板的系数分布近似于高斯分布，**高斯方差确定了平滑程度。方差越大，滤波结果越平滑；对于相同的方差，模板越大，结果越平滑。**
  
  对于一个$n^2$的二维高斯滤波模板，可以进行行列分离，从而降低计算复杂度：
  
  1. 首先将图像与一个一维高斯模板进行卷积
  2. 得到的结果与方向垂直的同一个模板进行卷积

### 2.3 锐化滤波

邻域的线性加权可以得到平滑的效果，反过来使用微分的方法可得到瑞华的效果。线性锐化滤波的模板仅中心的系数为正，周围的系数为负值。基本分类:

#### 高通滤波

中心区域为正，边缘区域为负，和为0

![high](http://media.innohub.top/190519-high.png)

由于模板的系数和为0，所以当模板通过像素稳定的区域时，输出为0或者比较小，需要一些放缩或者裁剪，用以补偿滤波后的负灰度级。

#### 微分滤波

1. 一阶微分滤波

   在离散空间，使用差分实现，常用的差分模板:
   ![$$
   \begin{bmatrix}
   -1      &  & 1      \\
   -1 &  & 1 \\
   -1     &  & 1
   \end{bmatrix}
   $$](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%20-1%20%26%20%26%201%20%5C%5C%20-1%20%26%20%26%201%20%5C%5C%20-1%20%26%20%26%201%20%5Cend%7Bbmatrix%7D)

   ![$$
   \begin{bmatrix}
   1     & 1 & 1      \\
    \\
   -1     & -1& -1
   \end{bmatrix}
   $$](http://latex.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%201%20%26%201%20%26%201%20%5C%5C%20%5C%5C%20-1%20%26%20-1%26%20-1%20%5Cend%7Bbmatrix%7D)

   

   他们结合构成一个梯度算子，对应差分公式
   ![$$
   \frac{\mathrm{d}f}{\mathrm{d}x} = f(x+1) - f(x)
   $$](http://latex.codecogs.com/gif.latex?%5Cfrac%7B%5Cmathrm%7Bd%7Df%7D%7B%5Cmathrm%7Bd%7Dx%7D%20%3D%20f%28x&plus;1%29%20-%20f%28x%29)

   + Robert
   + Prewitt
   + Sobel

2. 二阶微分

   Laplacian 

#### 高增益滤波器

### 2.4 图像降噪

1. 中值滤波。每一个像素的灰度值使用邻域中的中值代替。**可以用于去除椒盐噪声，同时可以保持边缘**
2. 均值滤波会破坏边缘
3. 中值滤波对于脉冲噪声非常有效；高斯滤波对于高斯噪声有效

 

### 2.5 一阶算子与二阶算子的比较

+ 一阶导数算子可以产生更厚的边缘
+ 二阶导数算子对于细节响应更强烈
+ **一阶导数算子对于灰度阶跃有更强的响应**
+ 二阶导数算子对于灰度阶跃产生双响应
+ 二阶导数算子对于一条直线的响应强于对于灰度阶跃的响应；对于一个点的响应强于对于一条线的响应

## 3. 边缘检测

边缘是图像中的一个比较低层的的**基元**，边缘检测通常使用梯度算子进行，分别计算沿X,Y两个方向的梯度。

实际中使用小区域模板进行近似计算，对于水平方向以及垂直方向各用一个模板，所以需要将两个模板组合起来构成一个梯度算子。**注意：水平方向的梯度算子得到的是垂直方向的边缘**

**边缘检测基本步骤：**

+ 平滑操作，去除噪声：高斯滤波，参数$\theta$决定了平滑程度

+ 边缘增强，使用滤波或者提高对比度

+ 边缘定位：确定滤波输出的局部最大值哪一个是边缘哪一个是噪声。

  使用阈值法，确定一个阈值，将小于该值的所有像素点置为0，大于者置为1

### 3.1 梯度的度量

![$$
\nabla f \approx |G_x| + |G_y|
$$](http://latex.codecogs.com/gif.latex?%5Cnabla%20f%20%5Capprox%20%7CG_x%7C%20&plus;%20%7CG_y%7C)

1. 罗伯特交叉算子
   ![$$
   G_x = (z_9 - z_5)\\G_y = (z_8 - z_6)
   $$](http://latex.codecogs.com/gif.latex?G_x%20%3D%20%28z_9%20-%20z_5%29%5C%5CG_y%20%3D%20%28z_8%20-%20z_6%29)
   由于实际计算是使用的是绝对值，所以Roberts算子也可以使用另一种形式的算子，结果一样。实质是交叉的求对角线方向的元素的灰度值的差，实际上计算所得的灰度值是交叉点处的值，所以图像整体偏移了半个像素。

2. 蒲瑞维特算子
   ![$$
   G_x = (z_3 + z_6+z_9) - (z_1+z_4+z_7) \\ G_y = (z_7+z_8+z_9) - (z_1+z_2+z_3)
   $$](http://latex.codecogs.com/gif.latex?G_x%20%3D%20%28z_3%20&plus;%20z_6&plus;z_9%29%20-%20%28z_1&plus;z_4&plus;z_7%29%20%5C%5C%20G_y%20%3D%20%28z_7&plus;z_8&plus;z_9%29%20-%20%28z_1&plus;z_2&plus;z_3%29)
   蒲瑞维特算子利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘。**对于噪声具有平滑作用，检测精度不够高。**

3. 索贝尔算子
   ![$$
   G_x = (z_3+2z_6+z_9) - (z_1+2z_4+z_7) \\ G_y = (z_7+2z_8+z_9) - (z_1+2z_2 +z_3)
   $$](http://latex.codecogs.com/gif.latex?G_x%20%3D%20%28z_3&plus;2z_6&plus;z_9%29%20-%20%28z_1&plus;2z_4&plus;z_7%29%20%5C%5C%20G_y%20%3D%20%28z_7&plus;2z_8&plus;z_9%29%20-%20%28z_1&plus;2z_2%20&plus;z_3%29)
   索贝尔算子利用邻域点的灰度值加权的方法，**根据边缘点处达到极值这一现象进行检测。索贝尔算子对于噪声具有平滑作用，提供较为精确地边缘方向信息，但同时会检测出许多伪边缘，定位精度不高。**

   一种改进的Sobel边缘检测方法：

   在传统sobel方法的基础之上，增加了6个方向的模板。角度值分别为:

   45、135,180,225,270,315,可以更加有效地检测各个方向的边缘

   ![sobel](http://media.innohub.top/190521-sobel.png)

   ### 3.2二阶微分的应用

   1. 拉普拉斯算子

   利用二阶导数过零点可以确定边缘位置，二阶微分也可以用于边缘检测。对于连续函数的拉普拉斯值定义为:
   ![$$
   \nabla ^2 f = \frac{\mathrm{d} ^2 f}{\mathrm{d} ^2 x ^2} + \frac{\mathrm{d} ^2 f}{\mathrm{d} ^2 y ^2} 
   $$](http://latex.codecogs.com/gif.latex?%5Cnabla%20%5E2%20f%20%3D%20%5Cfrac%7B%5Cmathrm%7Bd%7D%20%5E2%20f%7D%7B%5Cmathrm%7Bd%7D%20%5E2%20x%20%5E2%7D%20&plus;%20%5Cfrac%7B%5Cmathrm%7Bd%7D%20%5E2%20f%7D%7B%5Cmathrm%7Bd%7D%20%5E2%20y%20%5E2%7D)
   ![laplas](http://media.innohub.top/190521-las.png)

   对应的模板有以下要求:

   + 模板中心系数为正
   + 模板中心邻近系数为负
   + 所有系数的总和为0

   同时，为了完成边缘增强的任务，只需要在进行Laplacian算子滤波操作后，在加上原图。就可以得到边缘锐化。

   ![拉普拉斯的输出](http://media.innohub.top/190521-lapa.png)

   拉普拉斯滤波，边缘检测可以用于**图像锐化**，原始图像与经过拉普拉斯滤波得到的图像叠加可以实现边缘锐化。

   ![拉普拉斯模板](http://media.innohub.top/190521-lapa1.png)

   

2. 马尔算子

   马尔算子实在拉普拉斯基础上实现的边缘检测算子。为了减少噪声影响。可以先对图像进行高斯平滑。然后再使用拉普拉斯算子计算拉普拉斯值，最后检测图像中的过零点作为边缘点。又称为**高斯型拉普拉斯算子。**函数图形类似墨西哥草帽。
